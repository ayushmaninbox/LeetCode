Link: https://leetcode.com/problems/two-sum/

Given an array of integersÂ `nums`Â and an integerÂ `target`, returnÂ _indices of the two numbers such that they add up toÂ `target`_.

You may assume that each input would haveÂ **_exactly_Â one solution**, and you may not use theÂ _same_Â element twice.

You can return the answer in any order.

**Example 1:**

>**Input:**Â nums = [2, 7, 11, 15], target = 9
>**Output:**Â [0, 1]
>**Explanation:** Because nums[0] + nums[1] == 9, we return [0, 1].

**Example 2:**

>**Input:**Â nums = [3, 2, 4], target = 6
>**Output:**Â [1, 2]

**Example 3:**

>**Input:**Â nums = [3, 3], target = 6
>**Output:**Â [0, 1]

**Constraints:**

- `2 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`
- **Only one valid answer exists.**
---
### âœ… Solution 1 - Hashing Method

In this solution, we use a hash map (`unordered_map`) to store each number in the array as a key and its index as the value. In the first loop, we fill the map with all elements and their indices. Then, in the second loop, for each number, we calculate the difference (`target - nums[i]`) and check if that difference exists in the map. If it exists and the index of the difference is not the same as the current index (to avoid using the same element twice), we return both indices as the answer.

```
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> twoSums;
        for (int i = 0; i < nums.size(); i++) {
            twoSums[nums[i]] = i;
        }

        for (int i = 0; i < nums.size(); i++) {
            int diff = target - nums[i]; 
            if (twoSums[diff] && twoSums[diff] != i ) {
                return {i, twoSums[diff]};
            }
        }
        return {};
    }
};
```
#### Time complexity: O(n)
#### Space complexity: O(n)
---
### ðŸ““ Notes

--- Notes ---

