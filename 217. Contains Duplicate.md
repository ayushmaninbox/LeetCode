Link: https://leetcode.com/problems/contains-duplicate/

Given an integer array `nums`, return `true` if any value appears **at least twice** in the array, and return `false` if every element is distinct.

**Example 1:**

>**Input:** nums = [1, 2, 3, 1]
>**Output:** true
>**Explanation:**
>The element 1 occurs at the indices 0 and 3.

**Example 2:**

>**Input:** nums = [1, 2, 3, 4]
>**Output:** false
>**Explanation:**
>All elements are distinct.

**Example 3:**

>**Input:** nums = [1, 1, 1, 3, 3, 4, 3, 2, 4, 2]
>**Output:** true

**Constraints:**

- `1 <= nums.length <= 105`
- `-109 <= nums[i] <= 109`
---
### ❌ Solution 1 - Brute Force

Using 2 for-loops and comparing each element with the rest of the elements

```
class Solution {
public:
	bool containsDuplicate(vector<int>& nums) {
		int n = nums.size();
		for (int i = 0; i < n; i++) {
			for (int j = i + 1; j < n; j++) {
				if (nums[i] == nums[j]) return true;
			}
		}
		return false;
	}
};
```

#### Time complexity: O(n²)
#### Space complexity: O(1)
---
### ✅ Solution 2 - Sorting + Checking

By sorting the array first and then finding consecutive indices having same number or not

```
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        for (int i = 0; i < n - 1; i++) {
            if (nums[i] == nums[i + 1]) return true;
        }
        return false;
    }
};
```

#### Time complexity: O(n log n)
#### Space complexity: O(1) or O(n log n)
---
### ✅ Solution 3 - Hash Map

Using a hash map to track the frequency of elements:

```
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        unordered_map<int, int> HashMap;
        for (int i = 0; i < nums.size(); i++) {
            HashMap[nums[i]] += 1;
            if (HashMap[nums[i]] > 1) return true;
        }
        return false;
    }
};
```
#### Time complexity: O(n)
#### Space complexity: O(n)
---
### 📓 Notes

(none)

